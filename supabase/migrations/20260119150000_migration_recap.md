# CHANGELOG 009 ‚Äì Alignement DB avec UX/PRODUCT_MODEL

**Date** : 2026-01-19
**Objectif** : Corriger 4 incoh√©rences non-cosm√©tiques entre la DB Supabase et les documents de r√©f√©rence (ux.md, PRODUCT_MODEL.md)

---

## üìã R√©sum√© des Migrations

| Migration | Fichier                                           | Objet                            | Statut              |
| --------- | ------------------------------------------------- | -------------------------------- | ------------------- |
| **A**     | `20260119120000_add_sequence_parent_card.sql`     | S√©quen√ßage : lien parent_card_id | ‚úÖ Pr√™t             |
| **B**     | _(Aucune migration)_                              | Slots vides : logique frontend   | ‚úÖ Pas de migration |
| **C**     | `20260119130000_add_slot_completion.sql`          | √âtat "d√©j√† fait" : completed_at  | ‚úÖ Pr√™t             |
| **D**     | `20260119140000_enforce_sequence_constraints.sql` | Invariants mode='sequence'       | ‚úÖ Pr√™t             |

---

## üéØ (A) S√©quen√ßage : Attacher une s√©quence √† une carte parent (1-1)

### Probl√®me identifi√©

- **UX/Produit** : Une "s√©quence" est une timeline `mode='sequence'` rattach√©e √† une carte parent.
- **Invariant** : 1 carte = 0 ou 1 s√©quence (pas plusieurs).
- **DB actuelle** : Aucun lien entre `timelines` et `cards` pour les s√©quences.

### Solution impl√©ment√©e

‚úÖ Ajout colonne `timelines.parent_card_id` (uuid, nullable)
‚úÖ Contrainte `UNIQUE(parent_card_id) WHERE mode='sequence'` (garantit 1-1)
‚úÖ FK vers `cards(id) ON DELETE CASCADE`
‚úÖ Contrainte CHECK : `mode='sequence'` ‚áí `parent_card_id NOT NULL`, `mode='planning'` ‚áí `parent_card_id IS NULL`
‚úÖ RLS policy : owner de la carte parent = owner de la timeline

### Invariants garantis (serveur-side)

- ‚úÖ Une carte ne peut avoir qu'une seule s√©quence associ√©e
- ‚úÖ Une s√©quence doit avoir un parent_card_id
- ‚úÖ Un planning ne peut pas avoir de parent_card_id
- ‚úÖ Si carte parent supprim√©e ‚Üí s√©quence supprim√©e (CASCADE)
- ‚úÖ Owner carte parent = owner timeline (RLS)

### Impact frontend

- ‚ùå **Aucun changement n√©cessaire** (nouvelle feature, pas de code existant)
- ‚úÖ Impl√©menter bouton "Cr√©er/Modifier une s√©quence" sur cartes (√† venir)
- ‚úÖ Utiliser `parent_card_id` pour r√©cup√©rer la s√©quence d'une carte

---

## üéØ (B) Slots "vides" : Rendre l'UX possible sans casser la DB

### Probl√®me identifi√©

- **UX** : "1 slot reward + 1 slot step initiaux", "premier slot vide"
- **DB actuelle** : `slots.card_id NOT NULL` emp√™che slots vides

### Solution impl√©ment√©e

‚úÖ **Strat√©gie 1 : Pas de slots vides persist√©s**
‚úÖ **Aucune migration DB** : `card_id` reste `NOT NULL`
‚úÖ Logique frontend : L'UI g√®re les "emplacements vides" comme des positions calcul√©es

### Rationnal

- ‚úÖ Simplicit√© DB : pas de modifications de sch√©ma
- ‚úÖ Coh√©rence conceptuelle : un slot sans carte n'a pas de sens en DB (c'est juste un emplacement UI)
- ‚úÖ Performance : pas de lignes inutiles
- ‚úÖ Pas de dette technique : √©vite contraintes complexes sur slots vides

### Invariants (c√¥t√© frontend uniquement)

- ‚ùó "Premier slot vide" = calcul client (`max(position) + 1` pour un `slot_type` donn√©)
- ‚ùó UI affiche 1 slot reward + 1 slot step initiaux (m√™me si DB vide)
- ‚ùó Ajout dans "premier slot vide" = insertion avec `position` calcul√©e

### Impact frontend

- ‚ö†Ô∏è **Changement logique UI** : Calculer position dynamiquement
- ‚ö†Ô∏è Ne pas essayer d'ins√©rer des slots avec `card_id = NULL` (√©chec DB)
- ‚úÖ Algorithme : `INSERT INTO slots (timeline_id, card_id, slot_type, position) VALUES (..., max(position)+1)`

---

## üéØ (C) √âtat d'ex√©cution "d√©j√† fait" : Verrouillage serveur-side minimal

### Probl√®me identifi√©

- **UX** : "Quand un slot est 'fait', il devient non d√©pla√ßable / non supprimable"
- **DB actuelle** : Aucun √©tat de compl√©tion, protection uniquement frontend

### Solution impl√©ment√©e

‚úÖ Ajout colonnes `slots.completed_at` (timestamptz, nullable)
‚úÖ Ajout colonnes `slots.completed_by` (uuid, nullable)
‚úÖ Trigger `prevent_modify_completed_slot` : bloque DELETE et UPDATE position/card_id/slot_type sur slots compl√©t√©s
‚úÖ RLS policies : double protection (trigger + RLS)
‚úÖ Index partiel : optimise requ√™tes sur slots compl√©t√©s

### Invariants garantis (serveur-side)

- ‚úÖ Un slot compl√©t√© ne peut pas √™tre supprim√©
- ‚úÖ Un slot compl√©t√© ne peut pas avoir sa position modifi√©e (emp√™che r√©ordonnancement)
- ‚úÖ Un slot compl√©t√© ne peut pas changer de carte/type/timeline
- ‚úÖ Un slot compl√©t√© peut √™tre "uncompl√©t√©" (SET `completed_at = NULL`) par owner uniquement
- ‚úÖ Tra√ßabilit√© : `completed_by` pour audit

### Impact frontend

- ‚úÖ **Lors de validation d'un slot** : `UPDATE slots SET completed_at = NOW(), completed_by = auth.uid() WHERE id = ?`
- ‚úÖ **Afficher badge "D√©j√† fait"** : `WHERE completed_at IS NOT NULL`
- ‚úÖ **D√©sactiver drag & drop sur slots compl√©t√©s** : v√©rifier `completed_at IS NOT NULL`
- ‚úÖ **Permettre "uncomplete"** : `UPDATE slots SET completed_at = NULL WHERE id = ?` (si besoin)

---

## üéØ (D) Invariants "mode=sequence" : Interdire reward + jetons sur une s√©quence

### Probl√®me identifi√©

- **UX/Produit** : Les s√©quences (`mode='sequence'`) ne doivent contenir que des steps, jetons = 0, pas de reward
- **DB actuelle** : Aucune contrainte, on peut ins√©rer reward + jetons dans s√©quences

### Solution impl√©ment√©e

‚úÖ Migration de donn√©es : suppression slots reward sur s√©quences existantes (si pr√©sents)
‚úÖ Migration de donn√©es : mise √† 0 des jetons sur s√©quences existantes (si non-z√©ro)
‚úÖ Trigger `enforce_sequence_constraints` : valide avant INSERT/UPDATE sur `slots`
‚úÖ R√®gles :

- Si `mode='sequence'` : uniquement `slot_type='step'` + `jetons=0`
- Si `mode='planning'` : reward + jetons autoris√©s (pas de contraintes)

### Invariants garantis (serveur-side)

- ‚úÖ Une s√©quence ne peut contenir que des slots `type='step'`
- ‚úÖ Une s√©quence ne peut avoir de jetons (`jetons=0` sur tous les steps)
- ‚úÖ Un planning reste libre : reward + jetons autoris√©s
- ‚úÖ Impossible d'ins√©rer donn√©es incoh√©rentes (erreur explicite du trigger)

### Impact frontend

- ‚ùå **Aucun changement n√©cessaire** (contraintes transparentes pour le frontend bien √©crit)
- ‚úÖ En mode "Cr√©er s√©quence" : ne pas afficher s√©lecteur jetons (d√©j√† pr√©vu UX)
- ‚úÖ En mode "Cr√©er s√©quence" : ne pas afficher slot reward (d√©j√† pr√©vu UX)
- ‚ö†Ô∏è Si tentative d'ajout reward/jetons dans s√©quence ‚Üí erreur DB explicite

---

## üõ°Ô∏è Check Final : Invariants Garantis vs Assum√©s

### ‚úÖ Invariants garantis serveur-side (RLS + Triggers + Contraintes)

| Invariant                                 | M√©canisme                                      | Migration |
| ----------------------------------------- | ---------------------------------------------- | --------- |
| 1 carte = 0 ou 1 s√©quence                 | `UNIQUE(parent_card_id) WHERE mode='sequence'` | A         |
| S√©quence DOIT avoir parent_card_id        | `CHECK` + `NOT NULL` quand mode='sequence'     | A         |
| Planning NE DOIT PAS avoir parent_card_id | `CHECK` + `IS NULL` quand mode='planning'      | A         |
| Owner carte parent = owner timeline       | RLS policy `timelines_parent_card_owner_match` | A         |
| Slot compl√©t√© non supprimable             | Trigger `prevent_modify_completed_slot` + RLS  | C         |
| Slot compl√©t√© non d√©pla√ßable              | Trigger `prevent_modify_completed_slot`        | C         |
| S√©quence : uniquement steps               | Trigger `enforce_sequence_constraints`         | D         |
| S√©quence : jetons = 0                     | Trigger `enforce_sequence_constraints`         | D         |
| Planning : reward + jetons OK             | Contraintes existantes (pas modifi√©es)         | -         |

---

### ‚ùó Invariants encore c√¥t√© frontend (assum√©s MVP)

| Invariant                                   | Raison                   | Risque                                                           |
| ------------------------------------------- | ------------------------ | ---------------------------------------------------------------- |
| "Premier slot vide" = calcul client         | Pas de slots vides en DB | **Faible** : UI calcule position dynamiquement                   |
| 1 seul slot reward par planning             | Contrainte m√©tier UX     | **Moyen** : Pas de contrainte DB UNIQUE (ajout futur recommand√©) |
| Position continue (0, 1, 2, ...)            | Frontend g√®re ordre      | **Faible** : DB accepte positions non continues (flexible)       |
| Slots √âtapes num√©rot√©s "√âtape 1", "√âtape 2" | UI g√©n√®re libell√©s       | **Faible** : DB stocke uniquement position                       |

---

### ‚ö†Ô∏è Risques connus / Dettes conceptuelles restantes

| Risque                                         | Impact    | Mitigation recommand√©e                                                                        |
| ---------------------------------------------- | --------- | --------------------------------------------------------------------------------------------- |
| **1 reward par planning non garanti DB**       | üü° Moyen  | Ajouter contrainte `UNIQUE(timeline_id) WHERE slot_type='reward'` (migration future)          |
| **Slots vides g√©r√©s c√¥t√© UI uniquement**       | üü¢ Faible | Acceptable pour MVP, pas de donn√©e incoh√©rente possible                                       |
| **Compl√©tion des s√©quences non g√©r√©e**         | üü° Moyen  | Les s√©quences n'ont pas d'√©tat "compl√©t√©" (uniquement les slots). √Ä discuter selon UX finale. |
| **Pas de validation m√©tier "Planning valide"** | üü¢ Faible | Ex : "Timeline avec 0 slot" possible en DB mais incoh√©rent produit. Frontend g√®re.            |
| **Historique des compl√©tions limit√©**          | üü¢ Faible | `completed_at` unique, pas d'historique multi-compl√©tions. Acceptable MVP.                    |

---

## üìä Impact Performance Estim√©

| √âl√©ment                                              | Impact         | Justification                                                                       |
| ---------------------------------------------------- | -------------- | ----------------------------------------------------------------------------------- |
| **Ajout `parent_card_id` dans timelines**            | ‚úÖ N√©gligeable | Index automatique sur UNIQUE, pas de JOIN syst√©matique                              |
| **Ajout `completed_at` + `completed_by` dans slots** | ‚úÖ N√©gligeable | Colonnes nullables, index partiel optimis√©                                          |
| **Trigger `prevent_modify_completed_slot`**          | ‚úÖ N√©gligeable | Ex√©cut√© uniquement sur UPDATE/DELETE de slots, logique simple                       |
| **Trigger `enforce_sequence_constraints`**           | üü° L√©ger       | 1 SELECT sur timelines par INSERT/UPDATE slot. Acceptable pour fr√©quence d'√©dition. |
| **RLS policies suppl√©mentaires**                     | ‚úÖ N√©gligeable | Policies RESTRICTIVE, pas d'impact sur queries d√©j√† filtr√©es                        |

---

## üß™ Tests Recommand√©s (Post-Migration)

### Tests unitaires DB (SQL)

- [ ] Tenter d'ins√©rer 2 s√©quences sur la m√™me carte ‚Üí doit √©chouer (UNIQUE)
- [ ] Tenter d'ins√©rer s√©quence sans `parent_card_id` ‚Üí doit √©chouer (CHECK)
- [ ] Tenter d'ins√©rer planning avec `parent_card_id` ‚Üí doit √©chouer (CHECK)
- [ ] Tenter de supprimer une carte avec s√©quence ‚Üí doit supprimer s√©quence (CASCADE)
- [ ] Tenter de supprimer un slot compl√©t√© ‚Üí doit √©chouer (trigger)
- [ ] Tenter de d√©placer un slot compl√©t√© ‚Üí doit √©chouer (trigger)
- [ ] Tenter de "uncompleter" un slot ‚Üí doit r√©ussir
- [ ] Tenter d'ajouter reward dans s√©quence ‚Üí doit √©chouer (trigger)
- [ ] Tenter d'ajouter jetons dans s√©quence ‚Üí doit √©chouer (trigger)
- [ ] Ajouter reward dans planning ‚Üí doit r√©ussir

### Tests frontend (UI)

- [ ] Cr√©er une s√©quence depuis une carte ‚Üí v√©rifier `parent_card_id` stock√©
- [ ] Tenter de cr√©er 2√®me s√©quence sur m√™me carte ‚Üí doit bloquer (erreur DB)
- [ ] Valider un slot dans Tableau ‚Üí v√©rifier `completed_at` stock√©
- [ ] Tenter de d√©placer slot compl√©t√© en √âdition ‚Üí doit √™tre d√©sactiv√© (UI + erreur DB si contourn√©)
- [ ] Cr√©er s√©quence ‚Üí v√©rifier que jetons et reward sont masqu√©s
- [ ] Tenter d'ajouter reward dans s√©quence (si UI bug) ‚Üí doit √©chouer avec message clair

---

## üì¶ Rollback (Si Probl√®me Majeur)

**‚ö†Ô∏è ATTENTION** : Ces migrations modifient le sch√©ma et ajoutent des triggers. Rollback n√©cessite DROP manuel.

### Rollback migration D (Invariants sequence)

```sql
DROP TRIGGER IF EXISTS enforce_sequence_constraints_trigger ON public.slots;
DROP FUNCTION IF EXISTS public.enforce_sequence_constraints();
```

### Rollback migration C (√âtat compl√©tion)

```sql
DROP TRIGGER IF EXISTS prevent_modify_completed_slot_trigger ON public.slots;
DROP FUNCTION IF EXISTS public.prevent_modify_completed_slot();
DROP POLICY IF EXISTS slots_no_delete_completed ON public.slots;
DROP POLICY IF EXISTS slots_no_reorder_completed ON public.slots;
DROP INDEX IF EXISTS public.idx_slots_completed;
ALTER TABLE public.slots DROP COLUMN IF EXISTS completed_at;
ALTER TABLE public.slots DROP COLUMN IF EXISTS completed_by;
```

### Rollback migration A (S√©quen√ßage)

```sql
DROP POLICY IF EXISTS timelines_parent_card_owner_match ON public.timelines;
DROP INDEX IF EXISTS public.timelines_unique_parent_card_sequence;
ALTER TABLE public.timelines DROP CONSTRAINT IF EXISTS timelines_mode_parent_card_consistency;
ALTER TABLE public.timelines DROP CONSTRAINT IF EXISTS timelines_parent_card_id_fkey;
ALTER TABLE public.timelines DROP COLUMN IF EXISTS parent_card_id;
```

---

## üöÄ Prochaines √âtapes (Hors Scope MVP)

### Am√©liorations DB futures recommand√©es

1. **Contrainte 1 reward par planning** : `UNIQUE(timeline_id) WHERE slot_type='reward'`
2. **√âtat "timeline compl√©t√©e"** : Ajouter `timelines.completed_at` pour plannings finis
3. **Historique compl√©tions** : Table `slot_completions` pour multi-compl√©tions (analytics)
4. **Validation m√©tier "timeline valide"** : Trigger emp√™chant timelines vides ou incoh√©rentes
5. **Soft-delete timelines** : `timelines.deleted_at` pour archivage (RGPD)

### √âvolutions produit futures

- Partage de s√©quences entre utilisateurs
- Biblioth√®que de s√©quences pr√©d√©finies (banque)
- Templates de plannings r√©utilisables
- Statistiques compl√©tions (analytics)

---

## ‚úÖ Validation Finale

### Checklist avant d√©ploiement

- [ ] Les 3 migrations SQL sont valides et reproductibles
- [ ] Les triggers sont idempotents (DROP IF EXISTS avant CREATE)
- [ ] Les contraintes CHECK sont coh√©rentes avec les r√®gles produit
- [ ] Les RLS policies ne cassent pas l'acc√®s existant
- [ ] La migration de donn√©es (D) nettoie correctement les incoh√©rences
- [ ] Les commentaires SQL documentent clairement les invariants
- [ ] Les logs de migration sont explicites (RAISE NOTICE/WARNING)
- [ ] Aucune modification du frontend n'est requise (sauf nouvelle feature s√©quen√ßage)

---

**Fin du changelog 009**
**Auteur** : Claude Code
**Date** : 2026-01-19
