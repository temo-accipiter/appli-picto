// src/hooks/useSubscriptionStatus.js
import { useEffect, useState, useCallback, useRef } from 'react'
import { supabase } from '@/utils'
import useAuth from './useAuth'

/**
 * Retourne l'état d'abonnement courant de l'utilisateur.
 * - isActive: boolean (active/trialing/past_due et encore dans la période)
 * - status: string (ex: 'active' | 'trialing' | 'past_due' | 'canceled' | 'incomplete' | 'unpaid' | 'none')
 * - subscription: dernière ligne `abonnements` (ou null)
 * - loading: boolean
 * - refresh(): re-fetch manuel
 *
 * Hypothèses légères sur la table `abonnements` :
 * - colonnes : user_id (uuid), status (text), current_period_end (timestamp), created_at (timestamp)
 * - une ligne par abonnement Stripe (on prend la + récente)
 */
export default function useSubscriptionStatus() {
  const { user } = useAuth()
  const [loading, setLoading] = useState(true)
  const [status, setStatus] = useState('none')
  const [subscription, setSubscription] = useState(null)

  const channelRef = useRef(null)

  const parseIsActive = useCallback(sub => {
    if (!sub) return false
    const ACTIVE_STATUSES = ['active', 'trialing', 'past_due']
    const inActiveStatus = ACTIVE_STATUSES.includes(
      (sub.status || '').toLowerCase()
    )
    // Si la colonne current_period_end existe et est renseignée, on la respecte
    if (sub.current_period_end) {
      const now = new Date()
      const end = new Date(sub.current_period_end)
      return inActiveStatus && end > now
    }
    return inActiveStatus
  }, [])

  const refresh = useCallback(async () => {
    if (!user?.id) {
      setSubscription(null)
      setStatus('none')
      setLoading(false)
      return
    }

    setLoading(true)
    const { data, error } = await supabase
      .from('abonnements')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false })
      .limit(1)
      .maybeSingle()

    if (error) {
      console.warn('useSubscriptionStatus: erreur fetch abonnements', error)
      setSubscription(null)
      setStatus('none')
      setLoading(false)
      return
    }

    setSubscription(data || null)
    setStatus((data?.status || 'none').toLowerCase())
    setLoading(false)
  }, [user?.id])

  useEffect(() => {
    // initial fetch
    refresh()
  }, [refresh])

  useEffect(() => {
    // Realtime sur la table `abonnements` de l’utilisateur courant
    if (!user?.id) return

    // Nettoyage canal précédent
    if (channelRef.current) {
      supabase.removeChannel(channelRef.current)
      channelRef.current = null
    }

    const channel = supabase
      .channel(`abonnements:user:${user.id}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'abonnements',
          filter: `user_id=eq.${user.id}`,
        },
        () => {
          // re-fetch à chaque insert/update/delete concernant cet user
          refresh()
        }
      )
      .subscribe()

    channelRef.current = channel

    return () => {
      if (channelRef.current) {
        supabase.removeChannel(channelRef.current)
        channelRef.current = null
      }
    }
  }, [user?.id, refresh])

  const isActive = parseIsActive(subscription)

  return { isActive, status, subscription, loading, refresh }
}
